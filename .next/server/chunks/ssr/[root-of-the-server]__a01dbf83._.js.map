{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/google-genai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,6KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/branching-narrative-system.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines the Genkit flow for the BranchingNarrativeSystem story.\n *\n * - generateNextScenario - A function that generates the next game scenario based on player context.\n * - NarrativeInput - The input type for the generateNextScenario function.\n * - NarrativeOutput - The return type for the generateNextScenario function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst NarrativeInputSchema = z.object({\n  playerClass: z.string().describe('The class of the player character.'),\n  level: z.number().describe('The current level of the player.'),\n  location: z.string().describe('The current location in the game.'),\n  choices: z.array(z.object({\n    id: z.string().describe('The ID of the choice made.'),\n    text: z.string().describe('The text of the choice made.'),\n    tags: z.array(z.string()).describe('Tags associated with the choice (e.g., STEALTH, COMBAT, DIPLOMACY).'),\n  })).describe('The choices the player has made so far.'),\n  reputation: z.object({\n    stealth: z.number().describe('The player reputation for stealth.'),\n    combat: z.number().describe('The player reputation for combat.'),\n    diplomacy: z.number().describe('The player reputation for diplomacy.'),\n  }).describe('The player reputation.'),\n  unlockedPaths: z.array(z.string()).describe('The paths unlocked by the player.'),\n  questFlags: z.record(z.string(), z.any()).describe('The quest flags.'),\n});\nexport type NarrativeInput = z.infer<typeof NarrativeInputSchema>;\n\nconst NarrativeOutputSchema = z.object({\n  scenarioText: z.string().describe('The generated scenario text.'),\n  choices: z.array(z.object({\n    id: z.string().describe('A unique ID for the choice (e.g., \"A\", \"B\", \"C\").'),\n    text: z.string().describe('The text of the choice.'),\n    tags: z.array(z.string()).describe('An array of tags classifying the choice (e.g., COMBAT, DIPLOMACY, STEALTH).'),\n  })).describe('The choices available to the player.'),\n});\nexport type NarrativeOutput = z.infer<typeof NarrativeOutputSchema>;\n\nexport async function generateNextScenario(input: NarrativeInput): Promise<NarrativeOutput> {\n  return branchingNarrativeFlow(input);\n}\n\nconst branchingNarrativePrompt = ai.definePrompt({\n  name: 'branchingNarrativePrompt',\n  input: {schema: NarrativeInputSchema},\n  output: {schema: NarrativeOutputSchema},\n  prompt: `You are the Fartmaster, the master storyteller for Poot Quest. Your purpose is to weave a branching tale where success and chaos are both logical consequences of who the player isâ€”not random dice rolls, but fate filtered through the essence of their own gaseous soul.\n\n  **The Fartmaster's Creed:**\n  1.  **The World Remembers:** Every adventure must feel uniquely personal. NPCs must remember the character's actions and \"scents\" (reputation). Environments should respond to their personality. A character known for destructive rage might find already-shattered doorways, while a sneaky character finds paths others have missed.\n  2.  **Character is Fate:** Your narration must adapt and mutate the world based on the player's class, personality, and moral quirks. A Sneaky Rogue who slinks past danger might find their cowardice has consequences later. A Barbarian of Beans might destroy an obstacle with brute flatulence, permanently altering the map.\n  3.  **Ripple Effects:** Each decision, from the smell of courage to the aroma of betrayal, must ripple through the world. A compassionate act could lead to an unlikely ally. Greed could lead to cursed treasure. Overconfidence might cause a spell to literally backfire.\n\n  **Player Context Analysis:**\n  -   **Class:** {{playerClass}} (Level {{level}})\n  -   **Location:** {{location}}\n  -   **Reputation:** Stealth: {{reputation.stealth}}, Combat: {{reputation.combat}}, Diplomacy: {{reputation.diplomacy}}\n  -   **Past Choices & Actions:**\n      {{#each choices}}\n      - {{this.text}} ({{#each this.tags}}{{@key}}{{#if @last}}{{else}}, {{/if}}{{/each}})\n      {{/each}}\n  -   **Known Quests:** {{questFlags}}\n  -   **Unlocked Story Paths:** {{unlockedPaths}}\n\n  **Your Task:**\n  Analyze all of the above context. Generate the next scenario and three distinct, compelling choices (A, B, C).\n  1.  **Reactive Scenario:** Write a scenario that is a direct consequence of the character's being. If they are a high-combat barbarian, maybe they're ambushed by someone wanting to test their strength. If they are a high-diplomacy paladin who just negotiated peace, perhaps they are greeted as a hero.\n  2.  **Character-Driven Choices:** The choices you offer must reflect the character's core attributes. There should be at least one choice that aligns perfectly with their class or highest reputation score (e.g., a stealthy option for a Rogue, a diplomatic one for a Paladin).\n  3.  **Tag Your Choices:** Each choice must have at least one tag: \\`STEALTH\\`, \\`COMBAT\\`, or \\`DIPLOMACY\\`. You can add more descriptive tags if needed. A choice can have multiple tags, like \\`['COMBAT', 'GREED']\\`.\n\n  The output MUST conform to the schema. Make the story a living reflection of the player's soul.`,\n});\n\nconst branchingNarrativeFlow = ai.defineFlow(\n  {\n    name: 'branchingNarrativeFlow',\n    inputSchema: NarrativeInputSchema,\n    outputSchema: NarrativeOutputSchema,\n  },\n  async input => {\n    const {output} = await branchingNarrativePrompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,uBAAuB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACpC,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,SAAS,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACxB,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACxB,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC1B,MAAM,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACrC,IAAI,QAAQ,CAAC;IACb,YAAY,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACnB,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC7B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC5B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,GAAG,QAAQ,CAAC;IACZ,eAAe,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IAC5C,YAAY,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,uIAAA,CAAA,IAAC,CAAC,GAAG,IAAI,QAAQ,CAAC;AACrD;AAGA,MAAM,wBAAwB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,SAAS,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACxB,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QACxB,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;QAC1B,MAAM,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACrC,IAAI,QAAQ,CAAC;AACf;AAGO,eAAe,qBAAqB,KAAqB;IAC9D,OAAO,uBAAuB;AAChC;AAEA,MAAM,2BAA2B,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC/C,MAAM;IACN,OAAO;QAAC,QAAQ;IAAoB;IACpC,QAAQ;QAAC,QAAQ;IAAqB;IACtC,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;iGAwBsF,CAAC;AAClG;AAEA,MAAM,yBAAyB,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC1C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,yBAAyB;IAChD,OAAO;AACT;;;IA5CoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/flow-schemas.ts"],"sourcesContent":["import { z } from 'zod';\n\nexport const EncounterInputSchema = z.object({\n    playerClass: z.string().describe('The class of the player character.'),\n    playerLevel: z.number().describe('The current level of the player.'),\n    location: z.string().describe('The current location in the game.'),\n});\nexport type EncounterInput = z.infer<typeof EncounterInputSchema>;\n\nconst EnemySchema = z.object({\n    id: z.string().describe(\"A unique ID for this enemy instance, e.g., 'goblin-1'\"),\n    name: z.string().describe('The name of the enemy.'),\n    hp: z.number().describe('The health points of the enemy.'),\n    maxHp: z.number().describe('The maximum health points of the enemy.'),\n    imageUrl: z.string().describe('A public URL for an image of the enemy. Use a placeholder from picsum.photos.'),\n    attack: z.number().describe('The base attack power of the enemy.'),\n});\n\nconst LootSchema = z.object({\n    name: z.string().describe('The name of the loot item.'),\n    description: z.string().describe('A description of the loot item.'),\n    type: z.enum([\"weapon\", \"armor\", \"potion\", \"scroll\", \"misc\"]).describe('The type of the item.'),\n});\n\nexport const EncounterOutputSchema = z.object({\n    enemies: z.array(EnemySchema).describe('An array of enemies for the player to fight.'),\n    loot: LootSchema.describe('The loot awarded for winning the encounter.'),\n    introText: z.string().describe('A short, flavorful introductory text for the encounter.'),\n});\nexport type EncounterOutput = z.infer<typeof EncounterOutputSchema>;\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,uBAAuB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAClC;AAGA,MAAM,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzB,IAAI,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,MAAM,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,IAAI,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC3B,UAAU,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAChC;AAEA,MAAM,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxB,MAAM,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC1B,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,MAAM,oIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAU;QAAS;QAAU;QAAU;KAAO,EAAE,QAAQ,CAAC;AAC3E;AAEO,MAAM,wBAAwB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,SAAS,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,aAAa,QAAQ,CAAC;IACvC,MAAM,WAAW,QAAQ,CAAC;IAC1B,WAAW,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACnC","debugId":null}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-encounter-flow.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines the Genkit flow for generating combat encounters.\n *\n * - generateEncounter - A function that creates enemies and loot.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { EncounterInputSchema, EncounterOutputSchema, type EncounterOutput, type EncounterInput } from './flow-schemas';\n\n\nexport async function generateEncounter(input: EncounterInput): Promise<EncounterOutput> {\n    return generateEncounterFlow(input);\n}\n\nconst generateEncounterPrompt = ai.definePrompt({\n    name: 'generateEncounterPrompt',\n    input: { schema: EncounterInputSchema },\n    output: { schema: EncounterOutputSchema },\n    prompt: `You are the AI Dungeon Master for Poot Quest. Your task is to generate a challenging but fair combat encounter for the player.\n\n  Player Information:\n  - Class: {{playerClass}}\n  - Level: {{playerLevel}}\n  - Location: {{location}}\n\n  Based on this information, generate an encounter with the following properties:\n  1.  **Enemies**: Create a group of 1 to 3 enemies. The enemies should be thematically appropriate for the location. Their total difficulty should be a reasonable challenge for the player's level. Each enemy needs a unique ID.\n  2.  **Loot**: Generate one piece of loot that the player will receive if they win. The loot should be useful and interesting for the specified player class.\n  3.  **Intro Text**: Write a short, engaging introductory text (1-2 sentences) to set the scene for the battle.\n\n  Example Output:\n  {\n    \"enemies\": [\n      {\n        \"id\": \"sewer-goblin-1\",\n        \"name\": \"Sewer Goblin\",\n        \"hp\": 15,\n        \"maxHp\": 15,\n        \"imageUrl\": \"https://picsum.photos/seed/sewer-goblin/100/100\",\n        \"attack\": 3\n      },\n      {\n        \"id\": \"giant-rat-1\",\n        \"name\": \"Giant Rat\",\n        \"hp\": 10,\n        \"maxHp\": 10,\n        \"imageUrl\": \"https://picsum.photos/seed/giant-rat/100/100\",\n        \"attack\": 2\n      }\n    ],\n    \"loot\": {\n      \"name\": \"Rusty Dagger\",\n      \"description\": \"A simple but sharp dagger. Better than nothing.\",\n      \"type\": \"weapon\"\n    },\n    \"introText\": \"From the murky depths of the sewer, a goblin and his pet rat emerge, eyes gleaming with malice!\"\n  }`,\n});\n\nconst generateEncounterFlow = ai.defineFlow(\n    {\n        name: 'generateEncounterFlow',\n        inputSchema: EncounterInputSchema,\n        outputSchema: EncounterOutputSchema,\n    },\n    async (input) => {\n        const { output } = await generateEncounterPrompt(input);\n        return output!;\n    }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;CAIC,GAED;AACA;;;;;;AAGO,eAAe,kBAAkB,KAAqB;IACzD,OAAO,sBAAsB;AACjC;AAEA,MAAM,0BAA0B,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC5C,MAAM;IACN,OAAO;QAAE,QAAQ,qIAAA,CAAA,uBAAoB;IAAC;IACtC,QAAQ;QAAE,QAAQ,qIAAA,CAAA,wBAAqB;IAAC;IACxC,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCV,CAAC;AACJ;AAEA,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACvC;IACI,MAAM;IACN,aAAa,qIAAA,CAAA,uBAAoB;IACjC,cAAc,qIAAA,CAAA,wBAAqB;AACvC,GACA,OAAO;IACH,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,wBAAwB;IACjD,OAAO;AACX;;;IA1DkB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 519, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/adventure/%5Bclass%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {generateNextScenario as '4011378f80c37ba99068f177bd7b0eecf62137152f'} from 'ACTIONS_MODULE0'\nexport {generateEncounter as '406f825516d0ff63673568bbefb64c469386655af9'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA","debugId":null}},
    {"offset": {"line": 583, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/game/AdventureClient.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AdventureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call AdventureClient() from the server but AdventureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/game/AdventureClient.tsx <module evaluation>\",\n    \"AdventureClient\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,kBAAkB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjD;IAAa,MAAM,IAAI,MAAM;AAA8O,GAC3Q,yEACA","debugId":null}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/game/AdventureClient.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AdventureClient = registerClientReference(\n    function() { throw new Error(\"Attempted to call AdventureClient() from the server but AdventureClient is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/game/AdventureClient.tsx\",\n    \"AdventureClient\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,kBAAkB,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjD;IAAa,MAAM,IAAI,MAAM;AAA8O,GAC3Q,qDACA","debugId":null}},
    {"offset": {"line": 611, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 621, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/game/GameContainer.tsx"],"sourcesContent":["import { cn } from \"@/lib/utils\";\nimport type { ReactNode } from \"react\";\n\nexport function GameContainer({ children, className }: { children: ReactNode, className?: string }) {\n  return (\n    <div className={cn(\"container mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-8\", className)}>\n      {children}\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAGO,SAAS,cAAc,EAAE,QAAQ,EAAE,SAAS,EAA+C;IAChG,qBACE,8OAAC;QAAI,WAAW,CAAA,GAAA,mHAAA,CAAA,KAAE,AAAD,EAAE,yDAAyD;kBACzE;;;;;;AAGP","debugId":null}},
    {"offset": {"line": 644, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/adventure/%5Bclass%5D/page.tsx"],"sourcesContent":["import { AdventureClient } from \"@/components/game/AdventureClient\";\nimport { GameContainer } from \"@/components/game/GameContainer\";\nimport { Header } from \"@/components/game/Header\";\n\ntype Props = {\n  params: { class: string }; // 'class' is the characterId from the URL\n};\n\nexport default function AdventurePage({ params }: Props) {\n  const characterId = params.class;\n\n  return (\n    <>\n      <Header />\n      <main className=\"py-12\">\n        <GameContainer>\n          <AdventureClient characterId={characterId} />\n        </GameContainer>\n      </main>\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;AAMe,SAAS,cAAc,EAAE,MAAM,EAAS;IACrD,MAAM,cAAc,OAAO,KAAK;IAEhC,qBACE;;0BACE,8OAAC,oIAAA,CAAA,SAAM;;;;;0BACP,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,2IAAA,CAAA,gBAAa;8BACZ,cAAA,8OAAC,6IAAA,CAAA,kBAAe;wBAAC,aAAa;;;;;;;;;;;;;;;;;;AAKxC","debugId":null}}]
}